//
// OptionsWindow.java
//

/*
LOCI 4D Data Browser plugin for quick browsing of 4D datasets in ImageJ.
Copyright (C) 2005-@year@ Christopher Peterson, Francis Wong, Curtis Rueden
and Melissa Linkert.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Library General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Library General Public License for more details.

You should have received a copy of the GNU Library General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

package loci.plugins.browser;

import com.jgoodies.forms.layout.CellConstraints;
import com.jgoodies.forms.layout.FormLayout;
import java.awt.*;
import java.awt.event.*;
import java.io.IOException;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import loci.formats.*;
import loci.formats.cache.*;

/**
 * Window displaying custom virtualization options.
 *
 * <dl><dt><b>Source code:</b></dt>
 * <dd><a href="https://skyking.microscopy.wisc.edu/trac/java/browser/trunk/loci/plugins/browser/OptionsWindow.java">Trac</a>,
 * <a href="https://skyking.microscopy.wisc.edu/svn/java/trunk/loci/plugins/browser/OptionsWindow.java">SVN</a></dd></dl>
 */
public class OptionsWindow extends JFrame implements
  ActionListener, ChangeListener, ItemListener
{
  // -- Constants --

  /** Constant dlu size for indents in GUI. */
  private static final String TAB = "7dlu";

  /** Default number of time points to cache. */
  private static final int DEFAULT = 100;

  // -- Fields --

  /** Parent window. */
  private CustomWindow cw;

  /** CheckBoxes to control if caching is on or off. */
  private JCheckBox cacheToggle, mergeCheck;

  /** Spinners for slice storage. */
  private JSpinner zSpin, tSpin, cSpin;

  /** Combo Boxes for cache mode selection. */
  private JComboBox modeBox, stratBox;

  /** Combo Boxes for dimensional priority selection. */
  private JComboBox topBox, midBox, lowBox;

  /** Button to reset cache to default modes. */
  private JButton resetBtn;

  /** A flag to turn off listening to gui components. */
  private boolean update;

  /** Storage of what priority settings used to be. */
  private int oldTop, oldMid, oldLow;

  String id = null, order = null, suffix = null;
  String[] prefixes = null;
  int sizeZ = -1, sizeT = -1, sizeC = -1;
  int[] axes = null;
  FilePattern fp = null;

  JComboBox zGroup, tGroup, cGroup;

  // -- Constructor --
  public OptionsWindow(int numZ, int numT, CustomWindow c) {
    super("4D Data Browser - Options");
    setBackground(Color.GRAY);

    cw = c;

    update = false;

    Border etchB = BorderFactory.createEtchedBorder(EtchedBorder.LOWERED);

    // get FilePattern Data
    try {
      id = cw.db.id;
      cw.db.reader.setId(id);
      cw.db.reader.setSeries(cw.db.series);
      order = cw.db.reader.getDimensionOrder().substring(2);
      sizeZ = cw.db.reader.getSizeZ();
      sizeT = cw.db.reader.getSizeT();
      sizeC = cw.db.reader.getSizeC();
    }
    catch (FormatException exc) {
      LociDataBrowser.dumpException(exc);
    }
    catch (IOException exc) {
      LociDataBrowser.dumpException(exc);
    }

    // add Display Pane

    JPanel disPane = new JPanel();
    TitledBorder disB = BorderFactory.createTitledBorder(etchB, "Custom Axes");

    disPane.setBorder(disB);

    JLabel sliceLab = new JLabel("\u00B7" + "Slice-Groups in File" + "\u00B7");

    int left = id.indexOf("<");
    int right = id.indexOf(">");
    if (left != -1 && right != -1 && left < right) fp = new FilePattern(id);
    else fp = new FilePattern(new Location(id));

    try {
      prefixes = fp.getPrefixes();
      suffix = fp.getSuffix();
    }
    catch (NullPointerException exc) {
      // eat this exception, as it's only generated by images downloaded from
      // an OME server
    }

    Object[] choices = {"Z-Depth", "Time", "Channel"};
    zGroup = new JComboBox(choices);
    tGroup = new JComboBox(choices);
    cGroup = new JComboBox(choices);
    setBox(zGroup, 0);
    setBox(tGroup, 1);
    setBox(cGroup, 2);
    zGroup.addActionListener(this);
    tGroup.addActionListener(this);
    cGroup.addActionListener(this);

    JPanel slicePanel = new JPanel();
    slicePanel.add(sliceLab);
    slicePanel.setBackground(Color.DARK_GRAY);
    sliceLab.setForeground(Color.LIGHT_GRAY);

    JLabel zLab, tLab, cLab, fileLab;
    int[] internalSizes = new int[3];
    for (int i=0; i<internalSizes.length; i++) {
      internalSizes[i] = getOrderSize(i);
    }

    zLab = new JLabel("First ("+ internalSizes[0] + "):");
    tLab = new JLabel("Second (" + internalSizes[1] + "):");
    cLab = new JLabel("Third (" + internalSizes[2] + "):");
    fileLab = new JLabel("Filename:");

    String rowString = "pref," + TAB + ",pref,pref,pref," + TAB + ",pref,pref";
    for (int i=0; i<internalSizes.length; i++) {
      rowString += ",pref";
    }

    String colString = TAB + ",pref," + TAB + ",pref:grow," + TAB;
    FormLayout layout = new FormLayout(colString, rowString);
    disPane.setLayout(layout);
    CellConstraints cc = new CellConstraints();

    disPane.add(slicePanel, cc.xyw(1, 1, 5));
    disPane.add(zLab, cc.xy(2, 3));
    disPane.add(zGroup, cc.xy(4, 3));
    if (internalSizes[1] != 1) {
      disPane.add(tLab, cc.xy(2, 4));
      disPane.add(tGroup, cc.xy(4, 4));
    }
    if (internalSizes[2] != 1) {
      disPane.add(cLab, cc.xy(2, 5));
      disPane.add(cGroup, cc.xy(4, 5));
    }

    //set up animation options pane

    JPanel cachePane = new JPanel();
    TitledBorder cacheB = BorderFactory.createTitledBorder(
      etchB, "Caching Options");
    cachePane.setBorder(cacheB);

    JLabel typeL = new JLabel("\u00B7" + "Cache Type" + "\u00B7");
    JLabel axesL = new JLabel("Axes to Cache:");
    JLabel modeL = new JLabel("Cache Mode:");
    JLabel stratL = new JLabel("Loading Strategy:");
    JLabel sizeL = new JLabel("\u00B7" + "Slices to Store" + "\u00B7");
    JLabel zL = new JLabel("Z:");
    JLabel tL = new JLabel("T:");
    JLabel cL = new JLabel("C:");
    JLabel priorL = new JLabel("\u00B7" + "Axis Cacheing Priority" + "\u00B7");
    JLabel topL = new JLabel("Top Priority:");
    JLabel midL = new JLabel("Mid Priority:");
    JLabel lowL = new JLabel("Low Priority:");
    JLabel genL = new JLabel("\u00B7" + "General Controls" + "\u00B7");

    JPanel typePanel = new JPanel();
    typePanel.add(typeL);
    typePanel.setBackground(Color.DARK_GRAY);
    typeL.setForeground(Color.LIGHT_GRAY);
    JPanel sizePanel = new JPanel();
    sizePanel.add(sizeL);
    sizePanel.setBackground(Color.DARK_GRAY);
    sizeL.setForeground(Color.LIGHT_GRAY);
    JPanel priorPanel = new JPanel();
    priorPanel.add(priorL);
    priorPanel.setBackground(Color.DARK_GRAY);
    priorL.setForeground(Color.LIGHT_GRAY);
    JPanel genPanel = new JPanel();
    genPanel.add(genL);
    genPanel.setBackground(Color.DARK_GRAY);
    genL.setForeground(Color.LIGHT_GRAY);

    cacheToggle = new JCheckBox("Cache Images (on/off)");
    cacheToggle.setSelected(cw.db.virtual);
    cacheToggle.addItemListener(this);

    String[] modes = {"Crosshair", "Rectangle"};
    modeBox = new JComboBox(modes);
    String[] strats = {"Forward", "Surround"};
    stratBox = new JComboBox(strats);
    topBox = new JComboBox(choices);
    midBox = new JComboBox(choices);
    lowBox = new JComboBox(choices);
    topBox.setSelectedIndex(1);
    midBox.setSelectedIndex(0);
    lowBox.setSelectedIndex(2);
    modeBox.addActionListener(this);
    stratBox.addActionListener(this);
    topBox.addActionListener(this);
    midBox.addActionListener(this);
    lowBox.addActionListener(this);

    SpinnerNumberModel zMod = new SpinnerNumberModel(0, 0, 9999, 1);
    zSpin = new JSpinner(zMod);
    SpinnerNumberModel tMod = new SpinnerNumberModel(DEFAULT, 0, 9999, 1);
    tSpin = new JSpinner(tMod);
    SpinnerNumberModel cMod = new SpinnerNumberModel(0, 0, 9999, 1);
    cSpin = new JSpinner(cMod);
    zSpin.addChangeListener(this);
    tSpin.addChangeListener(this);
    cSpin.addChangeListener(this);

    resetBtn = new JButton("Reset cache to default");
    resetBtn.addActionListener(this);

    FormLayout layout3 = new FormLayout(
      TAB + ",pref," + TAB + ",pref:grow," + TAB + ",pref:grow," + TAB,
      "pref,pref,pref,pref," + TAB + ",pref,pref,pref,pref,pref," + TAB +
      ",pref," + TAB + ",pref,pref,pref," + TAB + ",pref," + TAB +
      ",pref," + TAB + ",pref");
    cachePane.setLayout(layout3);
    CellConstraints cc3 = new CellConstraints();

    cachePane.add(typePanel, cc3.xyw(1, 1, 7));
    cachePane.add(axesL, cc3.xyw(2, 2, 3));
    cachePane.add(modeL, cc3.xyw(2, 3, 3));
    cachePane.add(modeBox, cc3.xy(6, 3));
    cachePane.add(stratL, cc3.xyw(2, 4, 3));
    cachePane.add(stratBox, cc3.xy(6, 4));
    cachePane.add(sizePanel, cc3.xyw(1, 6, 7));
    cachePane.add(zL, cc3.xy(2, 8));
    cachePane.add(zSpin, cc3.xy(4, 8));
    cachePane.add(tL, cc3.xy(2, 9));
    cachePane.add(tSpin, cc3.xy(4, 9));
    cachePane.add(cL, cc3.xy(2, 10));
    cachePane.add(cSpin, cc3.xy(4, 10));
    cachePane.add(priorPanel, cc3.xyw(1, 12, 7));
    cachePane.add(topL, cc3.xyw(2, 14, 3));
    cachePane.add(topBox, cc3.xy(6, 14));
    cachePane.add(midL, cc3.xyw(2, 15, 3));
    cachePane.add(midBox, cc3.xy(6, 15));
    cachePane.add(lowL, cc3.xyw(2, 16, 3));
    cachePane.add(lowBox, cc3.xy(6, 16));
    cachePane.add(genPanel, cc3.xyw(1, 18, 7));
    cachePane.add(cacheToggle, cc3.xyw(2, 20, 5, "left,center"));
    cachePane.add(resetBtn, cc3.xyw(2, 22, 5, "right,center"));

    if (!cw.db.virtual) enableCache(false);

    // --Input Options Panel--

    JPanel inputPane = new JPanel();
    TitledBorder inputB = BorderFactory.createTitledBorder(
      etchB, "Input Options");
    inputPane.setBorder(inputB);

    mergeCheck = new JCheckBox("Merge Channels");
    mergeCheck.setSelected(cw.db.isMerged());
    mergeCheck.addItemListener(this);

    FormLayout inputLayout = new FormLayout(TAB + ",pref:grow," + TAB, "pref");
    inputPane.setLayout(inputLayout);
    CellConstraints cci = new CellConstraints();

    inputPane.add(mergeCheck, cci.xy(2, 1, "left,center"));

    //configure/layout content pane

    FormLayout lastLayout = new FormLayout("pref:grow", "pref,pref,pref");
    JPanel viewPanel = new JPanel(lastLayout);

    CellConstraints ccs = new CellConstraints();

    viewPanel.add(cachePane, ccs.xy(1, 1));
    viewPanel.add(disPane, ccs.xy(1, 2));
    viewPanel.add(inputPane, ccs.xy(1, 3));

    oldTop = topBox.getSelectedIndex();
    oldMid = midBox.getSelectedIndex();
    oldLow = lowBox.getSelectedIndex();

    JScrollPane jsp = new JScrollPane((Component) viewPanel);
    Dimension viewSize = viewPanel.getPreferredSize();
    jsp.setPreferredSize(new Dimension(viewSize.width + 20, 600));
    setContentPane(jsp);

    //useful frame method that handles closing of window
    setDefaultCloseOperation(HIDE_ON_CLOSE);
    //put frame in the right place, with the right size, and make visible
    setLocation(100, 100);
    pack();
    setVisible(true);

    update = true;
  }

  public static Color getColor(int i) {
    switch (i) {
      case 0:
        return Color.BLUE;
      case 1:
        return Color.GREEN;
      case 2:
        return Color.RED;
      case 3:
        return Color.MAGENTA;
      case 4:
        return Color.ORANGE;
      default:
        Color tempColor = getColor(i % 5);
        for (int j=0; j<i/5; j++) {
          tempColor.darker();
        }
        return tempColor;
    }
  }

  /** Set up the combo box to reflect appropriate axis. */
  private void setBox(JComboBox thisBox, int index) {
    thisBox.setSelectedIndex(convertChar(order.charAt(index)));
  }

  private char convertInt(int index) {
    switch (index) {
      case 0:
        return 'Z';
      case 1:
        return 'T';
      case 2:
        return 'C';
    }
    return 'Q';
  }

  private int convertChar(char c) {
    return c == 'Z' ? 0 : c == 'T' ? 1 : c == 'C' ? 2 : -1;
  }

  private int getOrderSize(int i) {
    char c = order.charAt(i);
    return c == 'Z' ? sizeZ : c == 'T' ? sizeT : c == 'C' ? sizeC : 1;
  }

  private int convert(int ndx) {
    return order.indexOf(convertInt(ndx));
  }

  private int getAxis(int i) {
    switch (i) {
      case 0:
        return AxisGuesser.Z_AXIS;
      case 1:
        return AxisGuesser.T_AXIS;
      case 2:
        return AxisGuesser.C_AXIS;
    }
    return -55555;
  }

  /** Enables/Disables cache options in option window. */
  private void enableCache(boolean enable) {
    modeBox.setEnabled(enable);
    stratBox.setEnabled(enable);
    topBox.setEnabled(enable);
    midBox.setEnabled(enable);
    lowBox.setEnabled(enable);

    zSpin.setEnabled(enable);
    tSpin.setEnabled(enable);
    cSpin.setEnabled(enable);

    resetBtn.setEnabled(enable);
  }

  // -- ActionListener API methods --

  public void actionPerformed(ActionEvent e) {
    if (!update) return;
    Object source = e.getSource();

    if (source == modeBox) {
      // change cache strategy

      int[] lengths = cw.db.cache.getStrategy().getLengths();
      int ndx = modeBox.getSelectedIndex();
      try {
        CacheStrategy strategy = ndx == 0 ?
          (CacheStrategy) new CrosshairStrategy(lengths) :
          (CacheStrategy) new RectangleStrategy(lengths);
        cw.db.cache.setStrategy(strategy);
      }
      catch (CacheException exc) {
        LociDataBrowser.dumpException(exc);
      }

      // set ranges, priorities, order
      updatePriorities();
      updateRanges();
      updateOrder();
      updateCacheIndicators();
    }
    else if (source == stratBox) {
      // change order in which axes are cached
      updateOrder();
    }
    else if (source == resetBtn) {
      // reset cache parameters to default values
      update = false;
      modeBox.setSelectedIndex(0);
      stratBox.setSelectedIndex(0);

      int[] lengths = cw.db.cache.getStrategy().getLengths();
      try {
        cw.db.cache.setStrategy(new CrosshairStrategy(lengths));
      }
      catch (CacheException exc) {
        LociDataBrowser.dumpException(exc);
      }

      int[] priorities = new int[] {ICacheStrategy.NORMAL_PRIORITY,
        ICacheStrategy.MAX_PRIORITY, ICacheStrategy.MIN_PRIORITY};
      int[] ranges = new int[] {0, 100, 0};

      for (int i=0; i<lengths.length; i++) {
        cw.db.cache.getStrategy().setOrder(ICacheStrategy.FORWARD_ORDER, i);
        cw.db.cache.getStrategy().setPriority(priorities[i], convert(i));
        cw.db.cache.getStrategy().setRange(ranges[i], convert(i));
      }

      topBox.setSelectedIndex(1);
      midBox.setSelectedIndex(0);
      lowBox.setSelectedIndex(2);

      Integer zeroI = new Integer(0);
      Integer defaultI = new Integer(DEFAULT);
      zSpin.setValue(zeroI);
      tSpin.setValue(defaultI);
      cSpin.setValue(zeroI);

      oldTop = topBox.getSelectedIndex();
      oldMid = midBox.getSelectedIndex();
      oldLow = lowBox.getSelectedIndex();
      update = true;
    }
    else if (source == topBox) {
      // update priorities, based on change to "top priority"
      int newTop = topBox.getSelectedIndex();
      if (newTop == oldTop) return;
      if (newTop == oldMid) {
        update = false;
        midBox.setSelectedIndex(oldTop);
        oldMid = oldTop;
        update = true;
      }
      if (newTop == oldLow) {
        update = false;
        lowBox.setSelectedIndex(oldTop);
        oldLow = oldTop;
        update = true;
      }

      oldTop = newTop;
      updatePriorities();
    }
    else if (source == midBox) {
      // update priorities, based on change to "medium priority"
      int newMid = midBox.getSelectedIndex();
      if (newMid == oldMid) return;
      if (newMid == oldTop) {
        update = false;
        topBox.setSelectedIndex(oldMid);
        oldTop = oldMid;
        update = true;
      }
      if (newMid == oldLow) {
        update = false;
        lowBox.setSelectedIndex(oldMid);
        oldLow = oldMid;
        update = true;
      }

      oldMid = newMid;
      updatePriorities();
    }
    else if (source == lowBox) {
      // update priorities, based on change to "low priority"
      int newLow = lowBox.getSelectedIndex();
      if (newLow == oldLow) return;
      if (newLow == oldTop) {
        update = false;
        topBox.setSelectedIndex(oldLow);
        oldTop = oldLow;
        update = true;
      }
      if (newLow == oldMid) {
        update = false;
        midBox.setSelectedIndex(oldLow);
        oldMid = oldLow;
        update = true;
      }

      oldLow = newLow;
      updatePriorities();
    }
    else if (source == zGroup) {
      char oldChar = order.charAt(0);
      int sel = zGroup.getSelectedIndex();
      char zChar = convertInt(sel);

      sel = tGroup.getSelectedIndex();
      char tChar = convertInt(sel);
      if (tChar == zChar) tChar = oldChar;

      sel = cGroup.getSelectedIndex();
      char cChar = convertInt(sel);
      if (cChar == zChar) cChar = oldChar;

      updateGroups(zChar, tChar, cChar);
    }
    else if (source == tGroup) {
      char oldChar = order.charAt(1);
      int sel = tGroup.getSelectedIndex();
      char tChar = convertInt(sel);

      sel = zGroup.getSelectedIndex();
      char zChar = convertInt(sel);
      if (zChar == tChar) zChar = oldChar;

      sel = cGroup.getSelectedIndex();
      char cChar = convertInt(sel);
      if (cChar == tChar) cChar = oldChar;

      updateGroups(zChar, tChar, cChar);
    }
    else if (source == cGroup) {
      char oldChar = order.charAt(2);
      int sel = cGroup.getSelectedIndex();
      char cChar = convertInt(sel);

      sel = zGroup.getSelectedIndex();
      char zChar = convertInt(sel);
      if (zChar == cChar) zChar = oldChar;

      sel = tGroup.getSelectedIndex();
      char tChar = convertInt(sel);
      if (tChar == cChar) tChar = oldChar;
      updateGroups(zChar, tChar, cChar);
    }
    updateCacheIndicators();
  }

  public void itemStateChanged(ItemEvent e) {
    if (!update) return;
    Object source = e.getItemSelectable();

    if (source == cacheToggle) {
      cw.db.toggleCache(e.getStateChange() != ItemEvent.DESELECTED);
    }
    else if (source == mergeCheck) {
      cw.db.toggleMerge();
    }
    updateCacheIndicators();
  }

  // -- ChangeListener API methods --

  public void stateChanged(ChangeEvent e) {
    if (!update) return;
    updateRanges();
    updateCacheIndicators();
  }

  // -- Helper methods --

  private void updateRanges() {
    int z = ((Integer) zSpin.getValue()).intValue();
    int t = ((Integer) tSpin.getValue()).intValue();
    int c = ((Integer) cSpin.getValue()).intValue();

    int[] ranges = new int[] {z, t, c};

    ICacheStrategy strategy = cw.db.cache.getStrategy();
    for (int i=0; i<strategy.getLengths().length; i++) {
      strategy.setRange(ranges[i], convert(i));
    }
  }

  private void updatePriorities() {
    cw.db.cache.getStrategy().setPriority(ICacheStrategy.MAX_PRIORITY,
      convert(topBox.getSelectedIndex()));
    cw.db.cache.getStrategy().setPriority(ICacheStrategy.NORMAL_PRIORITY,
      convert(midBox.getSelectedIndex()));
    cw.db.cache.getStrategy().setPriority(ICacheStrategy.MIN_PRIORITY,
      convert(lowBox.getSelectedIndex()));
  }

  private void updateOrder() {
    int cacheOrder = stratBox.getSelectedIndex() == 0 ?
      ICacheStrategy.FORWARD_ORDER : ICacheStrategy.CENTERED_ORDER;
    for (int i=0; i<cw.db.cache.getStrategy().getLengths().length; i++) {
      cw.db.cache.getStrategy().setOrder(cacheOrder, i);
    }
  }

  private void updateGroups(char zChar, char tChar, char cChar) {
    order = new String(new char[] {zChar, tChar, cChar});
    try {
      cw.db.reader.setId(id);
      cw.db.reader.setSeries(cw.db.series);
      cw.db.reader.swapDimensions("XY" + order);
      sizeZ = cw.db.reader.getSizeZ();
      sizeT = cw.db.reader.getSizeT();
      sizeC = cw.db.reader.getSizeC();
    }
    catch (Exception exc) {
      LociDataBrowser.dumpException(exc);
    }
    update = false;
    setBox(zGroup, 0);
    setBox(tGroup, 1);
    setBox(cGroup, 2);
    update = true;
    cw.db.setDimensions();
    cw.updateControls();
  }

  private void updateCacheIndicators() {
    if (cw.zIndicator != null) {
      cw.zIndicator.setIndicator(cw.db.cache, sizeZ, order.indexOf("Z"));
    }
    if (cw.tIndicator != null) {
      cw.tIndicator.setIndicator(cw.db.cache, sizeT, order.indexOf("T"));
    }
  }

}
